use std::{convert::Infallible, pin::Pin};

use actix_web::{body::BoxBody, dev::{ResponseHead, Service, ServiceRequest, ServiceResponse, Transform}, http::header::{Accept, ContentType, Header, Quality}, mime::{self, Mime}, Responder, ResponseError};
use serde::ser::SerializeMap;

struct Generator {
    mime: Mime,
    generator: fn(&dyn ResponseError, &ResponseHead) -> BoxBody,
}

const GENERATORS: [Generator; 2] = [
    Generator {
        mime: mime::TEXT_HTML_UTF_8,
        generator: generate_html,
    },
    Generator {
        mime: mime::APPLICATION_JSON,
        generator: generate_json,
    },
];

pub struct ErrorConversionMiddleware;

struct ErrorConversionService<T>(T);

struct ErrorConversionFuture<T>(T);

impl<S: Service<ServiceRequest, Response=ServiceResponse>> Transform<S, ServiceRequest> for ErrorConversionMiddleware {
    type Response = ServiceResponse;

    type Error = S::Error;

    type Transform = ErrorConversionService<S>;

    type InitError = ();

    type Future = std::future::Ready<Result<Self::Transform, ()>>;

    fn new_transform(&self, service: S) -> Self::Future {
        std::future::ready(Ok(ErrorConversionService(service)))
    }
}

impl<S: Service<ServiceRequest, Response=ServiceResponse>> Service<ServiceRequest> for ErrorConversionService<S> {
    type Response = ServiceResponse;

    type Error = S::Error;

    type Future = ErrorConversionFuture<S::Future>;

    fn poll_ready(&self, ctx: &mut core::task::Context<'_>) -> std::task::Poll<Result<(), Self::Error>> {
        self.0.poll_ready(ctx)
    }

    fn call(&self, req: ServiceRequest) -> Self::Future {
        ErrorConversionFuture(self.0.call(req))
    }
}

impl<E, F: Future<Output=Result<ServiceResponse, E>>> Future for ErrorConversionFuture<F> {
    type Output = Result<ServiceResponse, E>;

    fn poll(self: std::pin::Pin<&mut Self>, cx: &mut std::task::Context<'_>) -> std::task::Poll<Self::Output> {
        // SAFETY: pin projection
        let inner = unsafe {self.map_unchecked_mut(|x| &mut x.0)};
        inner.poll(cx).map(|r| r.map(convert_error))
    }
}

fn convert_error(resp: ServiceResponse) -> ServiceResponse {
    if let Some(error) = resp.response().error() {
        let Ok(accept_header) = Accept::parse(resp.request()) else {
            log::debug!("request had a malformed Accept header");
            // the Accept header failed to parse.  return the error message as is.  if the client
            // is messed up enough that it's sending malformed HTTP headers, sending the original
            // error message is likely to be more useful than complaining about that.
            return resp;
        };

        let preferences = accept_header.ranked();

        let Some((best_generator, generator_pos)) = find_best(&GENERATORS, &preferences) else {
            // None of the generators we have produce a content type acceptable to the client.
            // Hope wahtever was already in the response we were passed is.
            // If the client chokes on that output, that's its problem.
            return resp;
        };
        // actix only lets you parse() a header from a request, not a response, so we reimplement
        // that logic manually here
        // not sure what we should do on error in this case.
        if let Ok(response_type) = 
            actix_web::http::header::from_one_raw_str(
                resp
                .response() // response generated by the middleware below us
                .headers()
                .get(ContentType::name())
            )
            .map(ContentType)
        {
            if preferences.iter()
                .position(|preference| mime_matches(preference, &response_type.0))
                .is_some_and(|x| x <= generator_pos)
            {
                    // client prefers what the response already contains to anything we could
                    // generate.
                    return resp;
            }
        } else {
            log::error!("middleware reporting an error generated an invalid Content-Type header");
        }

        let new_body = (best_generator.generator)(error.as_response_error(), resp.response().head());

        resp.map_body(|_, _| new_body)
    } else {
        resp
    }
}

fn mime_matches(wildcard: &Mime, concrete: &Mime) -> bool {
    wildcard.type_() == "*" || (wildcard.type_() == concrete.type_() && (wildcard.subtype() == "*" || wildcard.subtype() == concrete.subtype()))
}

fn find_best<'a>(generators: &'a [Generator], preferences: &[Mime]) -> Option<(&'a Generator, usize)> {
    generators.iter()
        .filter_map(|g| preferences.iter()
            .position(|preference| mime_matches(preference, &g.mime))
            .map(|pos| (g,pos))
        )
        .min_by_key(|(_, pos)| *pos)
}

fn generate_html(error: &dyn ResponseError, head: &ResponseHead) -> BoxBody {
    BoxBody::new(format!("<!DOCTYPE html><html><body><h1>{} {}</h1><p>{}</p></body></html>", head.status, head.reason.unwrap_or(head.status.canonical_reason().unwrap_or("")), error))
}


fn generate_json(error: &dyn ResponseError, head: &ResponseHead) -> BoxBody {
    BoxBody::new(serde_json::to_string(&ErrorSerializable(error.to_string())).expect("serializer should never fail"))
}

struct ErrorSerializable(String);

impl serde::Serialize for ErrorSerializable {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer {
            let mut s = serializer.serialize_map(Some(1))?;
            s.serialize_key("error")?;
            s.serialize_value(&self.0)?;
            s.end()
    }
}


/*
fn get_quality(choices: &Accept, mime: &Mime) -> Quality {
    choices.0
        .iter()
        .rev()
        .filter(|x| mime_matches(&x.item, mime))
        .next()
        .map(|x| x.quality)
        .unwrap_or(Quality::ZERO)
}

fn find_best<'a>(generators: &'a [Generator], choices: &Accept) -> Option<&'a Generator> {
    generators.iter()
        .map(|g| (g, get_quality(choices, &g.mime)))
        .max_by_key(|(_, quality)| *quality)
        .filter(|(_, quality)| *quality != Quality::ZERO)
        .map(|(generator, _)| generator)
}
*/
