use actix_web::{body::BoxBody, dev::{ResponseHead, Service, ServiceRequest, ServiceResponse, Transform}, http::header::{self, Accept, ContentType, Header, TryIntoHeaderValue as _}, mime::{self, Mime}, ResponseError};
use serde::ser::SerializeMap;

struct Generator {
    mime: Mime,
    generator: fn(&dyn ResponseError, &ResponseHead) -> BoxBody,
}

const GENERATORS: [Generator; 2] = [
    Generator {
        mime: mime::TEXT_HTML_UTF_8,
        generator: generate_html,
    },
    Generator {
        mime: mime::APPLICATION_JSON,
        generator: generate_json,
    },
];

pub struct ErrorConversionMiddleware;

pub struct ErrorConversionService<T>(T);

pub struct ErrorConversionFuture<T>(T);

impl<S: Service<ServiceRequest, Response=ServiceResponse>> Transform<S, ServiceRequest> for ErrorConversionMiddleware {
    type Response = ServiceResponse;

    type Error = S::Error;

    type Transform = ErrorConversionService<S>;

    type InitError = ();

    type Future = std::future::Ready<Result<Self::Transform, ()>>;

    fn new_transform(&self, service: S) -> Self::Future {
        std::future::ready(Ok(ErrorConversionService(service)))
    }
}

impl<S: Service<ServiceRequest, Response=ServiceResponse>> Service<ServiceRequest> for ErrorConversionService<S> {
    type Response = ServiceResponse;

    type Error = S::Error;

    type Future = ErrorConversionFuture<S::Future>;

    fn poll_ready(&self, ctx: &mut core::task::Context<'_>) -> std::task::Poll<Result<(), Self::Error>> {
        self.0.poll_ready(ctx)
    }

    fn call(&self, req: ServiceRequest) -> Self::Future {
        ErrorConversionFuture(self.0.call(req))
    }
}

impl<E, F: Future<Output=Result<ServiceResponse, E>>> Future for ErrorConversionFuture<F> {
    type Output = Result<ServiceResponse, E>;

    fn poll(self: std::pin::Pin<&mut Self>, cx: &mut std::task::Context<'_>) -> std::task::Poll<Self::Output> {
        // SAFETY: pin projection
        let inner = unsafe {self.map_unchecked_mut(|x| &mut x.0)};
        inner.poll(cx).map(|r| r.map(convert_error))
    }
}

pub fn convert_error(mut sv_resp: ServiceResponse) -> ServiceResponse {
    if sv_resp.response().error().is_some() {
        let Ok(accept_header) = Accept::parse(sv_resp.request()) else {
            log::debug!("request had a malformed Accept header");
            // the Accept header failed to parse.  return the error message as is.  if the client
            // is messed up enough that it's sending malformed HTTP headers, sending the original
            // error message is likely to be more useful than complaining about that.
            return sv_resp;
        };

        let preferences = accept_header.ranked();

        let Some((best_generator, generator_pos)) = find_best(&GENERATORS, &preferences) else {
            // None of the generators we have produce a content type acceptable to the client.
            // Hope wahtever was already in the response we were passed is.
            // If the client chokes on that output, that's its problem.
            return sv_resp;
        };
        // actix only lets you parse() a header from a request, not a response, so we reimplement
        // that logic manually here
        // not sure what we should do on error in this case.
        if let Ok(response_type) = 
            actix_web::http::header::from_one_raw_str(
                sv_resp
                .response() // response generated by the middleware below us
                .headers()
                .get(ContentType::name())
            )
            .map(ContentType)
        {
            if preferences.iter()
                .position(|preference| mime_matches(preference, &response_type.0))
                .is_some_and(|x| x <= generator_pos)
            {
                    // client prefers what the response already contains to anything we could
                    // generate.
                    return sv_resp;
            }
        } else {
            log::error!("middleware reporting an error generated an invalid Content-Type header");
        }

        sv_resp.response_mut().headers_mut().insert(header::CONTENT_TYPE, best_generator.mime.clone().try_into_value().unwrap());
        sv_resp.response_mut().headers_mut().append(header::VARY, header::ACCEPT.into());

        // curse you borrow checker for not letting me if let Some(...) at the top and
        // response_mut() later in the function at the same time.
        let error = sv_resp.response().error().unwrap(); 

        let new_body = (best_generator.generator)(error.as_response_error(), sv_resp.response().head());

        sv_resp.map_body(|_, _| new_body)
    } else {
        sv_resp
    }
}

fn mime_matches(wildcard: &Mime, concrete: &Mime) -> bool {
    wildcard.type_() == "*" || (wildcard.type_() == concrete.type_() && (wildcard.subtype() == "*" || wildcard.subtype() == concrete.subtype()))
}

fn find_best<'a>(generators: &'a [Generator], preferences: &[Mime]) -> Option<(&'a Generator, usize)> {
    generators.iter()
        .filter_map(|g| preferences.iter()
            .position(|preference| mime_matches(preference, &g.mime))
            .map(|pos| (g,pos))
        )
        .min_by_key(|(_, pos)| *pos)
}

fn generate_html(error: &dyn ResponseError, _head: &ResponseHead) -> BoxBody {
    BoxBody::new(format!("<!DOCTYPE html><html><body><h1>{}</h1><p>{}</p></body></html>", error.status_code(), error))
}


fn generate_json(error: &dyn ResponseError, _head: &ResponseHead) -> BoxBody {
    BoxBody::new(serde_json::to_string(&ErrorSerializable(error.to_string())).expect("serializer should never fail"))
}

struct ErrorSerializable(String);

impl serde::Serialize for ErrorSerializable {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer {
            let mut s = serializer.serialize_map(Some(1))?;
            s.serialize_key("error")?;
            s.serialize_value(&self.0)?;
            s.end()
    }
}


/*
fn get_quality(choices: &Accept, mime: &Mime) -> Quality {
    choices.0
        .iter()
        .rev()
        .filter(|x| mime_matches(&x.item, mime))
        .next()
        .map(|x| x.quality)
        .unwrap_or(Quality::ZERO)
}

fn find_best<'a>(generators: &'a [Generator], choices: &Accept) -> Option<&'a Generator> {
    generators.iter()
        .map(|g| (g, get_quality(choices, &g.mime)))
        .max_by_key(|(_, quality)| *quality)
        .filter(|(_, quality)| *quality != Quality::ZERO)
        .map(|(generator, _)| generator)
}
*/

#[cfg(test)]
mod test {
    use actix_web::{body::MessageBody, error::InternalError, http::StatusCode, test::TestRequest, HttpRequest};

    use super::*;
    fn generate_test_request(accept: &str) -> HttpRequest {
        TestRequest::get().insert_header((header::ACCEPT, accept)).to_http_request()
    }
    fn generate_custom_test_response(accept: &str, error: impl ResponseError + 'static) -> ServiceResponse {
        ServiceResponse::from_err(error, generate_test_request(accept))
    }
    fn generate_test_response(accept: &str) -> ServiceResponse {
        generate_custom_test_response(accept, InternalError::new("scary error message", StatusCode::INTERNAL_SERVER_ERROR))
    }
    const ACCEPT_HTML: &str = "text/html,something/irrelevant;q=0.9,application/json;q=0.8,*/*;q=0.7"; // something a browser might emit
    const ACCEPT_JSON: &str = "application/json;q=0.9,text/html;q=0.8,*/*;q=0.7";
    const ACCEPT_JSON_2: &str = "text/html;q=0.8,application/json;q=0.9,*/*;q=0.7";
    const ACCEPT_ANY: &str = "*/*"; // something curl might emit
    // I actually just realized I have no idea how the Accept: header is supposed to be parsed.
    //const PREFER_PLAIN: &str = "something/irrelevant,*/*;q=0.9,text/html;q=0.8";
    
    fn do_test(accept_header: &str, expected_content_type: &str, expected_body: &str) {
        let response = convert_error(generate_test_response(accept_header));
        let response_content_type = response.headers().get(header::CONTENT_TYPE).expect("missing Content-Type header");
        assert_eq!(response_content_type, expected_content_type);
        let body = response.into_body().try_into_bytes().expect("error response should not produce a streaming body");
        let body = std::str::from_utf8(&body).expect("body was not valid utf8");
        assert_eq!(body, expected_body);
    }
    #[test]
    fn test_convert_error() {
        do_test(ACCEPT_HTML, "text/html; charset=utf-8", "<!DOCTYPE html><html><body><h1>500 Internal Server Error</h1><p>scary error message</p></body></html>");
        do_test(ACCEPT_JSON, "application/json", r#"{"error":"scary error message"}"#);
        do_test(ACCEPT_JSON_2, "application/json", r#"{"error":"scary error message"}"#);
        do_test(ACCEPT_ANY, "text/plain; charset=utf-8", "scary error message");
    }
}
